<div class="breakpoint">
	{{#if minWidth}}
		<div class="breakpoint-min {{isSelected ? 'is-selected' : ''}}" style="background-size:{{minWidth}} 100%"></div>
	{{/if}}
	{{#if maxWidth}}
		<div class="breakpoint-max {{isSelected ? 'is-selected' : ''}}" style="background-size:{{maxWidth}} 100%"></div>
	{{/if}}
	<button class="select-button" type="button" on:click='fire( "select", { bmin, bmax, boundary } )'>
		{{#if minWidth}}min: {{minWidth}} {{/if}}
		{{#if maxWidth}}max: {{maxWidth}} {{/if}}
	</button>
	{{#if isSelected}}
		<label for="resizer{{index}}">width</label> <input type="number" bind:value="bmin.value" />
		<input id="resizer{{index}}" class="resizer" type="range" min="0" max="{{viewportWidth}}" step="1" bind:value="bmin.value" />
	{{/if}}
</div>

<script>
	import deconstructDeclaration from './deconstructDeclaration';


	//	-/+ maintain recorded diff between min/max
	//	todo edit both min and max!
	//	min *and* max - todo make into handy array with both somewhere upstream
	function editBreakpoint(newMeasure) {
		console.log('editBreakpoint MediaLists', this._state.boundary.min.MediaLists);
		console.log('editBreakpoint arguments', arguments);
		console.log('editBreakpoint this', this);

		this._state.boundary.min.MediaLists.forEach((MediaList) => {

			var newMediaText = `(${newMeasure.minMax}-width: ${newMeasure.value}${newMeasure.unit})`;
			console.log('newMediaText', newMediaText);

			MediaList.mediaText = newMediaText;

			console.log('MediaList', MediaList);
		});

		this.fire('edit', { pixelWidth: this.get('bmin').value });
	}

	export default {
		oncreate () {
			console.log('breakpoint boundary', this.get('boundary') );

			const observeResize = this.observe('bmin', editBreakpoint.bind(this), { init: false });
		},

		helpers: {
		},
		methods: {
		},
		computed : {

			//	boundary rules
			minRule: boundary => boundary.min && boundary.min.widthRule,
// 			maxRule: boundary => boundary.max && boundary.max.widthRuleEdit || boundary.max.widthRule,

			//	values based on boundary min and max
			bmin: minRule => minRule && deconstructDeclaration(minRule),
// 			bmax: maxRule => maxRule && deconstructDeclaration(maxRule),

			//	widths based on boundary min and max
			minWidth: bmin => bmin && bmin.value + bmin.unit,
// 			maxWidth: bmax => bmax && bmax.value + bmax.unit,

			//	min and max built from merge - still boundary!
// 			min: (boundary, bmin) => boundary.min && Object.assign({}, boundary.min, bmin),
// 			max: (boundary, bmax) => boundary.max && Object.assign({}, boundary.max, bmax)
		}
	};
</script>
<style>
	.breakpoint {
		position: relative;
		text-align: center;
		border-top: 1px solid #bbb;
		border-bottom: 1px solid #bbb;
		margin-bottom: 0.7rem;
	}

	.breakpoint-min {
		height: 1rem;
		background-position: 50% center;
		background-repeat: no-repeat;
		background-color: #ddd;
		background-image: linear-gradient(#eee,#eee);
	}

	.breakpoint-min.is-selected {
		background-color: #6DA819;
		background-image: linear-gradient(#eee,#eee);
	}

	.breakpoint-max {
		height: 1rem;
		background-position: 50% center;
		background-repeat: no-repeat;
		background-color: #eee;
		background-image: linear-gradient(#ddd,#ddd);
	}

	.breakpoint-max.is-selected {
		background-color: #eee;
		background-image: linear-gradient(#6DA819,#6DA819);
	}

	.select-button {
		padding: 0.2rem 0.6rem;
		border: 1px solid #aaa;
		border-radius: 0px 0px 0.6rem 0.6rem;
		background-color: #fff;
		position: absolute;
		top: -1px;
		left: 50%;
		transform: translate(-50%);
	}
</style>